#include "PHY.hh"

std::mutex liquid_mutex;

union PHYHeader {
    Header h;
    // FLEXFRAME_H_USER in liquid.internal.h. This is the largest header of any
    // of the liquid PHY implementations.
    unsigned char bytes[14];
};

// Initial modulation buffer size
const size_t kInitialModbufSize = 16384;

py::array_t<std::complex<float>> Modulator::modulate(const Header &hdr, py::buffer payload)
{
    auto buf = payload.request();

    assemble(&hdr, buf.ptr, buf.size);

    py::array_t<std::complex<float>> iqarr(kInitialModbufSize);
    auto                             iqbuf = iqarr.request();

    // Number of generated samples in the buffer
    size_t nsamples = 0;
    // Max number of samples generated by modulateSamples
    const size_t kMaxModSamples = maxModulatedSamples();
    // Number of samples written
    size_t nw;
    // Flag indicating when we've reached the last symbol
    bool last_symbol = false;

    while (!last_symbol) {
        last_symbol = modulateSamples(&static_cast<std::complex<float>*>(iqbuf.ptr)[nsamples], nw);
        nsamples += nw;

        // If we can't add another nw samples to the current IQ buffer, resize it.
        if (nsamples + kMaxModSamples > (size_t) iqbuf.size) {
            iqarr.resize({2*iqarr.size()});
            iqbuf = iqarr.request();
        }
    }

    // Resize the final buffer to the number of samples generated.
    iqarr.resize({nsamples});

    return iqarr;
}

Demodulator::demod_vec Demodulator::demodulate(py::array_t<std::complex<float>, py::array::c_style | py::array::forcecast> sig)
{
    demod_vec result;

    packets_ = &result;

    auto buf = sig.request();

    demodulateSamples(static_cast<std::complex<float>*>(buf.ptr), buf.size);

    return result;
}

int Demodulator::liquid_callback(unsigned char *  header_,
                                 int              header_valid_,
                                 unsigned char *  payload_,
                                 unsigned int     payload_len_,
                                 int              payload_valid_,
                                 framesyncstats_s stats_,
                                 void *           userdata_)
{
    return reinterpret_cast<Demodulator*>(userdata_)->
        callback(header_,
                 header_valid_,
                 payload_,
                 payload_len_,
                 payload_valid_,
                 stats_);
}

int Demodulator::callback(unsigned char *  header_,
                          int              header_valid_,
                          unsigned char *  payload_,
                          unsigned int     payload_len_,
                          int              payload_valid_,
                          framesyncstats_s stats_)
{
    std::optional<Header>    h;
    std::optional<py::bytes> payload;
    FrameStats               stats;

    stats2framestats(stats_, stats);

    if (header_valid_)
        h = *((Header *) header_);

    if (payload_valid_)
        payload = py::bytes(reinterpret_cast<char*>(payload_), payload_len_);

    packets_->push_back(std::make_tuple(h, payload, stats));

    return 0;
}
