#include "Logger.hh"
#include "phy/Liquid.hh"
#include "phy/MultiOFDM.hh"

// Number of channels. We only use 1!
const unsigned int NUM_CHANNELS = 1;

// liquid fixes the header size at 8 bytes
static_assert(sizeof(Header) <= 8, "sizeof(Header) must be no more than 8 bytes");

MultiOFDM::Modulator::Modulator(MultiOFDM& phy)
  : LiquidModulator(phy)
  , myphy_(phy)
{
    std::lock_guard<std::mutex> lck(liquid_mutex);

    // modem setup (list is for parallel demodulation)
    mctx_ = std::make_unique<multichanneltx>(NUM_CHANNELS,
                                             myphy_.M_,
                                             myphy_.cp_len_,
                                             myphy_.taper_len_,
                                             myphy_.p_);
}

MultiOFDM::Modulator::~Modulator()
{
}

void MultiOFDM::Modulator::assemble(unsigned char *hdr, NetPacket& pkt)
{
    mctx_->UpdateData(0,
                      hdr,
                      pkt.data(),
                      pkt.size(),
                      pkt.tx_params->mcs.ms,
                      pkt.tx_params->mcs.fec0,
                      pkt.tx_params->mcs.fec1);
}

// Number of samples generated by a call to GenerateSamples.
const size_t NGEN = 2;

size_t MultiOFDM::Modulator::maxModulatedSamples(void)
{
    return NGEN;
}

bool MultiOFDM::Modulator::modulateSamples(std::complex<float> *buf, size_t &nw)
{
    nw = NGEN;

    mctx_->GenerateSamples(buf);
    return mctx_->IsChannelReadyForData(0);
}

MultiOFDM::Demodulator::Demodulator(MultiOFDM& phy)
  : LiquidDemodulator(phy)
  , myphy_(phy)
{
    internal_oversample_fact_ = 2;

    std::lock_guard<std::mutex> lck(liquid_mutex);

    // modem setup (list is for parallel demodulation)
    framesync_callback callback[1] = { &LiquidDemodulator::liquid_callback };
    void               *userdata[1] = { this };

    mcrx_ = std::make_unique<multichannelrx>(NUM_CHANNELS,
                                             myphy_.M_,
                                             myphy_.cp_len_,
                                             myphy_.taper_len_,
                                             myphy_.p_,
                                             userdata,
                                             callback);
}

MultiOFDM::Demodulator::~Demodulator()
{
}

void MultiOFDM::Demodulator::liquidReset(void)
{
    mcrx_->Reset();
}

void MultiOFDM::Demodulator::demodulateSamples(std::complex<float> *buf, const size_t n)
{
    mcrx_->Execute(buf, n);
}

std::unique_ptr<PHY::Demodulator> MultiOFDM::make_demodulator(void)
{
    return std::unique_ptr<PHY::Demodulator>(static_cast<PHY::Demodulator*>(new Demodulator(*this)));
}

std::unique_ptr<PHY::Modulator> MultiOFDM::make_modulator(void)
{
    return std::unique_ptr<PHY::Modulator>(static_cast<PHY::Modulator*>(new Modulator(*this)));
}
