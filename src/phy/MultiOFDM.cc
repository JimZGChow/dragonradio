#include "Logger.hh"
#include "liquid/Mutex.hh"
#include "phy/LiquidPHY.hh"
#include "phy/MultiOFDM.hh"

// Number of channels. We only use 1!
const unsigned int NUM_CHANNELS = 1;

// liquid fixes the header size at 8 bytes
static_assert(sizeof(Header) <= 8, "sizeof(Header) must be no more than 8 bytes");

MultiOFDM::Modulator::Modulator(MultiOFDM& phy)
  : LiquidPHY::Modulator(phy)
  , myphy_(phy)
{
    std::lock_guard<std::mutex> lck(Liquid::mutex);

    // modem setup (list is for parallel demodulation)
    mctx_ = std::make_unique<multichanneltx>(NUM_CHANNELS,
                                             myphy_.M_,
                                             myphy_.cp_len_,
                                             myphy_.taper_len_,
                                             myphy_.p_);
}

MultiOFDM::Modulator::~Modulator()
{
}

void MultiOFDM::Modulator::assemble(unsigned char *hdr, NetPacket& pkt)
{
    mctx_->UpdateData(0,
                      hdr,
                      pkt.data(),
                      pkt.size(),
                      pkt.tx_params->mcs.ms,
                      pkt.tx_params->mcs.fec0,
                      pkt.tx_params->mcs.fec1);
}

// Number of samples generated by a call to GenerateSamples.
const size_t NGEN = 2;

size_t MultiOFDM::Modulator::maxModulatedSamples(void)
{
    return NGEN;
}

bool MultiOFDM::Modulator::modulateSamples(std::complex<float> *buf, size_t &nw)
{
    nw = NGEN;

    mctx_->GenerateSamples(buf);
    return mctx_->IsChannelReadyForData(0);
}

MultiOFDM::Demodulator::Demodulator(MultiOFDM& phy)
  : LiquidPHY::Demodulator(phy)
  , myphy_(phy)
{
    internal_oversample_fact_ = 2;

    std::lock_guard<std::mutex> lck(Liquid::mutex);

    // modem setup (list is for parallel demodulation)
    framesync_callback callback[1] = { &LiquidPHY::Demodulator::liquid_callback };
    void               *userdata[1] = { this };

    mcrx_ = std::make_unique<multichannelrx>(NUM_CHANNELS,
                                             myphy_.M_,
                                             myphy_.cp_len_,
                                             myphy_.taper_len_,
                                             myphy_.p_,
                                             userdata,
                                             callback);
}

MultiOFDM::Demodulator::~Demodulator()
{
}

void MultiOFDM::Demodulator::liquidReset(void)
{
    mcrx_->Reset();
}

void MultiOFDM::Demodulator::demodulateSamples(std::complex<float> *buf, const size_t n)
{
    mcrx_->Execute(buf, n);
}

size_t MultiOFDM::getModulatedSize(const TXParams &params, size_t n)
{
    ofdmflexframegen        fg;
    ofdmflexframegenprops_s fgprops;
    size_t                  nsymbols;

    // Copy TXParams to framegen props
    fgprops.check = params.mcs.check;
    fgprops.fec0 = params.mcs.fec0;
    fgprops.fec1 = params.mcs.fec1;
    fgprops.mod_scheme = params.mcs.ms;

    // Create framegen object
    {
        std::lock_guard<std::mutex> lck(Liquid::mutex);

        fg = ofdmflexframegen_create(M_, cp_len_, taper_len_, p_, &fgprops);
    }

    // Set framegen header props
#if LIQUID_VERSION_NUMBER >= 1003001
    ofdmflexframegenprops_s header_props { header_mcs_.check
                                         , header_mcs_.fec0
                                         , header_mcs_.fec1
                                         , header_mcs_.ms
                                         };

    ofdmflexframegen_set_header_props(fg, &header_props);
    ofdmflexframegen_set_header_len(fg, sizeof(Header));
#endif /* LIQUID_VERSION_NUMBER >= 1003001 */

    // Create dummy data and assemble frame
    std::vector<unsigned char> hdr(sizeof(Header));
    std::vector<unsigned char> body(n);

    ofdmflexframegen_reset(fg);
    ofdmflexframegen_assemble(fg, hdr.data(), body.data(), body.size());

    // Get size of assembled frame
    nsymbols = ofdmflexframegen_getframelen(fg);

    // Destroy framegen object
    ofdmflexframegen_destroy(fg);

    return getTXUpsampleRate()*nsymbols;
}

std::unique_ptr<PHY::Demodulator> MultiOFDM::mkDemodulator(void)
{
    return std::unique_ptr<PHY::Demodulator>(static_cast<PHY::Demodulator*>(new Demodulator(*this)));
}

std::unique_ptr<PHY::Modulator> MultiOFDM::mkModulator(void)
{
    return std::unique_ptr<PHY::Modulator>(static_cast<PHY::Modulator*>(new Modulator(*this)));
}
