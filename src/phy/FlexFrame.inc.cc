#include "Logger.hh"
#include "phy/FlexFrame.inc.hh"

union PHYHeader {
    Header h;
    // FLEXFRAME_H_USER in liquid.internal.h
    unsigned char bytes[14];
};

FlexFrame::Modulator::Modulator(FlexFrame &phy)
  : LiquidModulator(phy)
  , myphy_(phy)
{
    std::lock_guard<std::mutex> lck(liquid_mutex);

    flexframe(genprops_init_default)(&fgprops_);
    fg_ = flexframe(gen_create)(&fgprops_);

#if LIQUID_VERSION_NUMBER >= 1003001
    flexframe(genprops_s) header_props { phy.header_mcs_.check
                                       , phy.header_mcs_.fec0
                                       , phy.header_mcs_.fec1
                                       , phy.header_mcs_.ms
                                       };

    flexframe(gen_set_header_props)(fg_, &header_props);
    flexframe(gen_set_header_len)(fg_, sizeof(Header));
#endif /* LIQUID_VERSION_NUMBER >= 1003001 */
}

FlexFrame::Modulator::~Modulator()
{
    flexframe(gen_destroy)(fg_);
}

void FlexFrame::Modulator::print(void)
{
    flexframe(gen_print)(fg_);
}

void FlexFrame::Modulator::update_props(const TXParams &params)
{
    if (fgprops_.check != params.mcs.check ||
        fgprops_.fec0 != params.mcs.fec0 ||
        fgprops_.fec1 != params.mcs.fec1 ||
        fgprops_.mod_scheme != params.mcs.ms) {
        fgprops_.check = params.mcs.check;
        fgprops_.fec0 = params.mcs.fec0;
        fgprops_.fec1 = params.mcs.fec1;
        fgprops_.mod_scheme = params.mcs.ms;

        flexframe(gen_setprops)(fg_, &fgprops_);
    }
}

// Number of samples generated by a call to flexframegen_write_samples.
const size_t NGEN = 2;

// Initial sample buffer size
const size_t MODBUF_SIZE = 16384;

void FlexFrame::Modulator::modulate(ModPacket& mpkt, std::shared_ptr<NetPacket> pkt)
{
    PHYHeader header;

    memset(&header, 0, sizeof(header));

    pkt->toHeader(header.h);

    pkt->resize(std::max((size_t) pkt->size(), myphy_.min_pkt_size_));

    update_props(*(pkt->tx_params));
    flexframe(gen_reset)(fg_);
    flexframe(gen_assemble)(fg_, header.bytes, pkt->data(), pkt->size());

    // Buffer holding generated IQ samples
    auto iqbuf = std::make_unique<IQBuf>(MODBUF_SIZE);
    // Number of generated samples in the buffer
    size_t nsamples = 0;
    // Local copy of gain
    const float g = pkt->g;
    // Flag indicating when we've reached the last symbol
    bool last_symbol = false;

    while (!last_symbol) {
#if LIQUID_VERSION_NUMBER >= 1003000 && defined(NEWFLEXFRAME)
        last_symbol = flexframe(gen_write_samples)(fg_,
          reinterpret_cast<liquid_float_complex*>(&(*iqbuf)[nsamples]), NGEN);
#else /* LIQUID_VERSION_NUMBER < 1003000 */
        last_symbol = flexframe(gen_write_samples)(fg_,
          reinterpret_cast<liquid_float_complex*>(&(*iqbuf)[nsamples]));
#endif /* LIQUID_VERSION_NUMBER < 1003000 */

        // Apply soft gain. Note that this is where nsamples is incremented.
        for (unsigned int i = 0; i < NGEN; i++)
            (*iqbuf)[nsamples++] *= g;

        // If we can't add another NGEN samples to the current IQ buffer, resize
        // it.
        if (nsamples + NGEN > iqbuf->size())
            iqbuf->resize(2*iqbuf->size());
    }

    // Resize the final buffer to the number of samples generated.
    iqbuf->resize(nsamples);

    // Fill in the ModPacket
    mpkt.samples = std::move(iqbuf);
    mpkt.pkt = std::move(pkt);
}

FlexFrame::Demodulator::Demodulator(FlexFrame &phy)
  : LiquidDemodulator(phy)
{
    std::lock_guard<std::mutex> lck(liquid_mutex);

    fs_ = flexframe(sync_create)(&LiquidDemodulator::liquid_callback, this);

#if LIQUID_VERSION_NUMBER >= 1003001
    flexframe(genprops_s) header_props { phy.header_mcs_.check
                                       , phy.header_mcs_.fec0
                                       , phy.header_mcs_.fec1
                                       , phy.header_mcs_.ms
                                       };

    flexframe(sync_set_header_props)(fs_, &header_props);
    flexframe(sync_set_header_len)(fs_, sizeof(Header));
    flexframe(sync_decode_header_soft)(fs_, phy.soft_header_);
    flexframe(sync_decode_payload_soft)(fs_, phy.soft_payload_);
#endif /* LIQUID_VERSION_NUMBER >= 1003001 */
}

FlexFrame::Demodulator::~Demodulator()
{
    flexframe(sync_destroy)(fs_);
}

void FlexFrame::Demodulator::print(void)
{
    flexframe(sync_print)(fs_);
}

void FlexFrame::Demodulator::reset(Clock::time_point timestamp, size_t off)
{
    flexframe(sync_reset)(fs_);

    demod_start_ = timestamp;
    demod_off_ = off;
}

void FlexFrame::Demodulator::demodulate(std::complex<float>* data,
                                        size_t count,
                                        std::function<void(std::unique_ptr<RadioPacket>)> callback)
{
    callback_ = callback;

    flexframe(sync_execute)(fs_, reinterpret_cast<liquid_float_complex*>(data), count);
}

std::unique_ptr<PHY::Demodulator> FlexFrame::make_demodulator(void)
{
    return std::unique_ptr<PHY::Demodulator>(static_cast<PHY::Demodulator*>(new Demodulator(*this)));
}

std::unique_ptr<PHY::Modulator> FlexFrame::make_modulator(void)
{
    return std::unique_ptr<PHY::Modulator>(static_cast<PHY::Modulator*>(new Modulator(*this)));
}
