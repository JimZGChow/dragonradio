#include "Logger.hh"
#include "liquid/Mutex.hh"
#include "phy/FlexFrame.inc.hh"

FlexFrame::Modulator::Modulator(FlexFrame &phy)
  : LiquidPHY::Modulator(phy)
  , myphy_(phy)
{
    std::lock_guard<std::mutex> lck(Liquid::mutex);

    flexframe(genprops_init_default)(&fgprops_);
    fg_ = flexframe(gen_create)(&fgprops_);

#if LIQUID_VERSION_NUMBER >= 1003001
    flexframe(genprops_s) header_props;

    mcs2flexframegenprops(phy.header_mcs_, header_props);
    flexframe(gen_set_header_props)(fg_, &header_props);
    flexframe(gen_set_header_len)(fg_, sizeof(Header));
#endif /* LIQUID_VERSION_NUMBER >= 1003001 */
}

FlexFrame::Modulator::~Modulator()
{
    flexframe(gen_destroy)(fg_);
}

void FlexFrame::Modulator::print(void)
{
    flexframe(gen_print)(fg_);
}

void FlexFrame::Modulator::update_props(const TXParams &params)
{
    if (fgprops_ != params.mcs) {
        mcs2flexframegenprops(params.mcs, fgprops_);
        flexframe(gen_setprops)(fg_, &fgprops_);
    }
}

void FlexFrame::Modulator::assemble(unsigned char *hdr, NetPacket& pkt)
{
    update_props(*(pkt.tx_params));
    flexframe(gen_reset)(fg_);
    flexframe(gen_assemble)(fg_, hdr, pkt.data(), pkt.size());
}

// Number of samples generated by a call to flexframegen_write_samples.
const size_t NGEN = 2;

size_t FlexFrame::Modulator::maxModulatedSamples(void)
{
    return NGEN;
}

bool FlexFrame::Modulator::modulateSamples(std::complex<float> *buf, size_t &nw)
{
    nw = NGEN;

#if LIQUID_VERSION_NUMBER >= 1003000 && defined(NEWFLEXFRAME)
    return flexframe(gen_write_samples)(fg_, buf, NGEN);
#else /* LIQUID_VERSION_NUMBER < 1003000 */
    return flexframe(gen_write_samples)(fg_, buf);
#endif /* LIQUID_VERSION_NUMBER < 1003000 */
}

FlexFrame::Demodulator::Demodulator(FlexFrame &phy)
  : LiquidPHY::Demodulator(phy)
{
    std::lock_guard<std::mutex> lck(Liquid::mutex);

    fs_ = flexframe(sync_create)(&LiquidPHY::Demodulator::liquid_callback, this);

#if LIQUID_VERSION_NUMBER >= 1003001
    flexframe(genprops_s) header_props;

    mcs2flexframegenprops(phy.header_mcs_, header_props);
    flexframe(sync_set_header_props)(fs_, &header_props);
    flexframe(sync_set_header_len)(fs_, sizeof(Header));
    flexframe(sync_decode_header_soft)(fs_, phy.soft_header_);
    flexframe(sync_decode_payload_soft)(fs_, phy.soft_payload_);
#endif /* LIQUID_VERSION_NUMBER >= 1003001 */
}

FlexFrame::Demodulator::~Demodulator()
{
    flexframe(sync_destroy)(fs_);
}

void FlexFrame::Demodulator::print(void)
{
    flexframe(sync_print)(fs_);
}

void FlexFrame::Demodulator::liquidReset(void)
{
    flexframe(sync_reset)(fs_);
}

void FlexFrame::Demodulator::demodulateSamples(std::complex<float> *buf, const size_t n)
{
    flexframe(sync_execute)(fs_, buf, n);
}

size_t FlexFrame::getModulatedSize(const TXParams &params, size_t n)
{
    flexframe(gen)        fg;
    flexframe(genprops_s) fgprops;
    size_t                nsymbols;

    // Copy TXParams to framegen props
    mcs2flexframegenprops(params.mcs, fgprops);

    // Create framegen object
    {
        std::lock_guard<std::mutex> lck(Liquid::mutex);

        fg = flexframe(gen_create)(&fgprops);
    }

    // Set framegen header props
#if LIQUID_VERSION_NUMBER >= 1003001
    flexframe(genprops_s) header_props;

    mcs2flexframegenprops(header_mcs_, header_props);
    flexframe(gen_set_header_props)(fg, &header_props);
    flexframe(gen_set_header_len)(fg, sizeof(Header));
#endif /* LIQUID_VERSION_NUMBER >= 1003001 */

    // Create dummy data and assemble frame
    std::vector<unsigned char> hdr(sizeof(Header));
    std::vector<unsigned char> body(n);

    flexframe(gen_reset)(fg);
    flexframe(gen_assemble)(fg, hdr.data(), body.data(), body.size());

    // Get size of assembled frame
    nsymbols = NGEN*flexframe(gen_getframelen)(fg);

    // Destroy framegen object
    flexframe(gen_destroy)(fg);

    return getTXUpsampleRate()*nsymbols;
}

std::unique_ptr<PHY::Demodulator> FlexFrame::mkDemodulator(void)
{
    return std::unique_ptr<PHY::Demodulator>(static_cast<PHY::Demodulator*>(new Demodulator(*this)));
}

std::unique_ptr<PHY::Modulator> FlexFrame::mkModulator(void)
{
    return std::unique_ptr<PHY::Modulator>(static_cast<PHY::Modulator*>(new Modulator(*this)));
}
