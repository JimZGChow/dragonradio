#ifndef LIQUID_MULTIOFDM_HH_
#define LIQUID_MULTIOFDM_HH_

#include <complex>
#include <functional>

#include <liquid/liquid.h>

#include <liquid/multichannelrx.h>
#include <liquid/multichanneltx.h>

#include "liquid/PHY.hh"

// Number of channels. We only use 1!
const unsigned int NUM_CHANNELS = 1;

// liquid fixes the header size at 8 bytes
static_assert(sizeof(Header) <= 8, "sizeof(Header) must be no more than 8 bytes");

namespace Liquid {

class MultiOFDMModulator : public Modulator {
public:
    MultiOFDMModulator(unsigned M,
                       unsigned cp_len,
                       unsigned taper_len,
                       const std::vector<unsigned char> &p = {})
      : M_(M)
      , cp_len_(cp_len)
      , taper_len_(taper_len)
      , p_(p)
    {
        std::lock_guard<std::mutex> lck(Liquid::mutex);

        // modem setup (list is for parallel demodulation)
        mctx_ = std::make_unique<multichanneltx>(NUM_CHANNELS,
                                                 M_,
                                                 cp_len_,
                                                 taper_len_,
                                                 p_.size() == 0 ? nullptr : const_cast<unsigned char*>(p_.data()));
    }

    virtual ~MultiOFDMModulator() = default;

    MultiOFDMModulator(const MultiOFDMModulator &) = delete;
    MultiOFDMModulator(MultiOFDMModulator &&) = delete;

    MultiOFDMModulator &operator=(const MultiOFDMModulator &) = delete;
    MultiOFDMModulator &operator=(MultiOFDMModulator &&) = delete;

    void print(void) override
    {
    }

    void assemble(const void *header,
                  const void *payload,
                  const size_t payload_len) override
    {
        mctx_->UpdateData(0,
                          static_cast<unsigned char*>(const_cast<void*>(header)),
                          static_cast<unsigned char*>(const_cast<void*>(payload)),
                          payload_len,
                          payload_mcs_.ms,
                          payload_mcs_.fec0,
                          payload_mcs_.fec1);
    }

    // Number of samples generated by a call to GenerateSamples.
    static constexpr size_t NGEN = 2;

    size_t assembledSize(void) override
    {
        size_t acc = 0;
        size_t nw;
        std::complex<float> buf[NGEN];

        while(modulateSamples(buf, nw))
            acc += nw;

        acc += nw;

        return acc;
    }

    size_t maxModulatedSamples(void) override
    {
        return NGEN;
    }

    bool modulateSamples(std::complex<float> *buf, size_t &nw) override
    {
        nw = NGEN;

        mctx_->GenerateSamples(buf);
        return mctx_->IsChannelReadyForData(0);
    }

protected:
    /* @brief The number of subcarriers */
    unsigned M_;

    /* @brief cp_len The cyclic prefix length */
    unsigned cp_len_;

    /* @brief taper_len The taper length (OFDM symbol overlap) */
    unsigned taper_len_;

    /* @param p The subcarrier allocation (null, pilot, data). Should have M
     * entries
     */
    std::vector<unsigned char> p_;

    /** @brief Our liquid-usrp multichanneltx object. */
    std::unique_ptr<multichanneltx> mctx_;

    void reconfigureHeader(void) override
    {
    }

    void reconfigurePayload(void) override
    {
    }
};

class MultiOFDMDemodulator : public Demodulator {
public:
    MultiOFDMDemodulator(bool soft_header,
                         bool soft_payload,
                         unsigned M,
                         unsigned cp_len,
                         unsigned taper_len,
                         const std::vector<unsigned char> &p = {})
        : Demodulator(soft_header, soft_payload)
        , M_(M)
        , cp_len_(cp_len)
        , taper_len_(taper_len)
        , p_(p)
    {
        std::lock_guard<std::mutex> lck(Liquid::mutex);

        // modem setup (list is for parallel demodulation)
        framesync_callback callback[1] = { &Demodulator::liquid_callback };
        void               *userdata[1] = { this };

        mcrx_ = std::make_unique<multichannelrx>(NUM_CHANNELS,
                                                 M_,
                                                 cp_len_,
                                                 taper_len_,
                                                 p_.size() == 0 ? nullptr : const_cast<unsigned char*>(p_.data()),
                                                 userdata,
                                                 callback);
    }

    virtual ~MultiOFDMDemodulator() = default;

    MultiOFDMDemodulator(const MultiOFDMDemodulator &) = delete;
    MultiOFDMDemodulator(MultiOFDMDemodulator &&) = delete;

    MultiOFDMDemodulator &operator==(const MultiOFDMDemodulator &) = delete;
    MultiOFDMDemodulator &operator!=(const MultiOFDMDemodulator &) = delete;

    void print(void) override
    {
    }

    void reset(void) override
    {
        mcrx_->Reset();
    }

    void demodulateSamples(const std::complex<float> *buf,
                           const size_t n) override
    {
        mcrx_->Execute(const_cast<std::complex<float>*>(buf), n);
    }

protected:
    /* @brief The number of subcarriers */
    unsigned M_;

    /* @brief cp_len The cyclic prefix length */
    unsigned cp_len_;

    /* @brief taper_len The taper length (OFDM symbol overlap) */
    unsigned taper_len_;

    /* @param p The subcarrier allocation (null, pilot, data). Should have M
     * entries
     */
    std::vector<unsigned char> p_;

    /** @brief Our liquid-usrp multichannelrx object. */
    std::unique_ptr<multichannelrx> mcrx_;

    void reconfigureHeader(void) override
    {
    }

    void reconfigureSoftDecode(void) override
    {
    }
};

}

#endif /* LIQUID_MULTIOFDM_HH_ */
