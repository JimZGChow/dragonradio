#ifndef LIQUID_NEWFLEXFRAME_HH_
#define LIQUID_NEWFLEXFRAME_HH_

#include <complex>
#include <functional>

#include <liquid/liquid.h>

#include "dsp/FFTW.hh"
#include "liquid/Modem.hh"

namespace Liquid {

class NewFlexFrameModulator : virtual public Modulator {
public:
    NewFlexFrameModulator(const MCS &header_mcs)
      : Modulator(header_mcs)
    {
        std::lock_guard<std::mutex> liquid_lock(Liquid::mutex);
        std::lock_guard<std::mutex> fftw_lock(fftw::mutex);

        flexframegenprops_s props;

        mcs2genprops(payload_mcs_, props);
        fg_ = flexframegen_create(&props);

        reconfigureHeader();
    }

    virtual ~NewFlexFrameModulator()
    {
        if (fg_) {
            std::lock_guard<std::mutex> liquid_lock(Liquid::mutex);
            std::lock_guard<std::mutex> fftw_lock(fftw::mutex);

            flexframegen_destroy(fg_);
        }
    }

    NewFlexFrameModulator() = delete;

    NewFlexFrameModulator(const NewFlexFrameModulator &) = delete;
    NewFlexFrameModulator(NewFlexFrameModulator &&) = delete;

    NewFlexFrameModulator &operator=(const NewFlexFrameModulator &) = delete;
    NewFlexFrameModulator &operator=(NewFlexFrameModulator &&) = delete;

    void print(void) override
    {
        flexframegen_print(fg_);
    }

    void assemble(const Header *header,
                  const void *payload,
                  const size_t payload_len) override
    {
        flexframegen_reset(fg_);
        flexframegen_assemble(fg_,
                              reinterpret_cast<unsigned char*>(const_cast<Header*>(header)),
                              static_cast<unsigned char*>(const_cast<void*>(payload)),
                              payload_len);
    }

    virtual unsigned getOversampleRate(void)
    {
        return 2;
    }

    // Number of samples generated by a call to flexframegen_write_samples.
    static constexpr size_t NGEN = 2;

    size_t assembledSize(void) override
    {
        return NGEN*flexframegen_getframelen(fg_);
    }

    size_t maxModulatedSamples(void) override
    {
        return NGEN;
    }

    bool modulateSamples(std::complex<float> *buf, size_t &nw) override
    {
        nw = NGEN;

        return flexframegen_write_samples(fg_, buf, NGEN);
    }

protected:
    /* @brief Flexframe generator object */
    flexframegen fg_;

    void reconfigureHeader(void) override
    {
        flexframegenprops_s props;

        mcs2genprops(header_mcs_, props);
        flexframegen_set_header_props(fg_, &props);
        flexframegen_set_header_len(fg_, sizeof(Header));
    }

    void reconfigurePayload(void) override
    {
        flexframegenprops_s props;

        mcs2genprops(payload_mcs_, props);
        flexframegen_setprops(fg_, &props);
    }
};

class NewFlexFrameDemodulator : virtual public Demodulator {
public:
    NewFlexFrameDemodulator(const MCS &header_mcs,
                            bool soft_header,
                            bool soft_payload)
      : Demodulator(header_mcs, soft_header, soft_payload)
    {
        std::lock_guard<std::mutex> liquid_lock(Liquid::mutex);
        std::lock_guard<std::mutex> fftw_lock(fftw::mutex);

        fs_ = flexframesync_create(&Demodulator::liquid_callback,
                                   static_cast<Demodulator*>(this));

        reconfigureHeader();
        reconfigureSoftDecode();
    }

    virtual ~NewFlexFrameDemodulator()
    {
        if (fs_) {
            std::lock_guard<std::mutex> liquid_lock(Liquid::mutex);
            std::lock_guard<std::mutex> fftw_lock(fftw::mutex);

            flexframesync_destroy(fs_);
        }
    }

    NewFlexFrameDemodulator() = delete;

    NewFlexFrameDemodulator(const NewFlexFrameDemodulator &) = delete;
    NewFlexFrameDemodulator(NewFlexFrameDemodulator &&) = delete;

    NewFlexFrameDemodulator &operator==(const NewFlexFrameDemodulator &) = delete;
    NewFlexFrameDemodulator &operator!=(const NewFlexFrameDemodulator &) = delete;

    virtual unsigned getOversampleRate(void)
    {
        return 2;
    }

    bool isFrameOpen(void) override
    {
        return flexframesync_is_frame_open(fs_);
    }

    void print(void) override
    {
        flexframesync_print(fs_);
    }

    void reset(void) override
    {
        flexframesync_reset(fs_);
    }

    void demodulateSamples(const std::complex<float> *buf,
                           const size_t n) override
    {
        flexframesync_execute(fs_, const_cast<std::complex<float>*>(buf), n);
    }

protected:
    /* @brief Flexframe synchronizer object */
    flexframesync fs_;

    void reconfigureHeader(void) override
    {
        flexframegenprops_s props;

        mcs2genprops(header_mcs_, props);
        flexframesync_set_header_props(fs_, &props);
        flexframesync_set_header_len(fs_, sizeof(Header));
    }

    void reconfigureSoftDecode(void) override
    {
        flexframesync_decode_header_soft(fs_, soft_header_);
        flexframesync_decode_payload_soft(fs_, soft_payload_);
    }
};

}

#endif /* LIQUID_NEWFLEXFRAME_HH_ */
