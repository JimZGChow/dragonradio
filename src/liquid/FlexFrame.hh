// Copyright 2018-2020 Drexel University
// Author: Geoffrey Mainland <mainland@drexel.edu>

#ifndef LIQUID_FLEXFRAME_HH_
#define LIQUID_FLEXFRAME_HH_

#include <complex>
#include <functional>

#include <liquid/liquid.h>

#include "dsp/FFTW.hh"
#include "liquid/Modem.hh"

namespace Liquid {

class FlexFrameModulator : virtual public Modulator {
public:
    FlexFrameModulator(const MCS &header_mcs)
      : Modulator(header_mcs)
    {
        std::lock_guard<std::mutex> liquid_lock(Liquid::mutex);
        std::lock_guard<std::mutex> fftw_lock(fftw::mutex);

        origflexframegenprops_s props;

        mcs2genprops(payload_mcs_, props);
        fg_ = origflexframegen_create(&props);

        reconfigureHeader();
    }

    virtual ~FlexFrameModulator()
    {
        if (fg_) {
            std::lock_guard<std::mutex> liquid_lock(Liquid::mutex);
            std::lock_guard<std::mutex> fftw_lock(fftw::mutex);

            origflexframegen_destroy(fg_);
        }
    }

    FlexFrameModulator() = delete;

    FlexFrameModulator(const FlexFrameModulator &) = delete;
    FlexFrameModulator(FlexFrameModulator &&) = delete;

    FlexFrameModulator &operator=(const FlexFrameModulator &) = delete;
    FlexFrameModulator &operator=(FlexFrameModulator &&) = delete;

    void print(void) override
    {
        origflexframegen_print(fg_);
    }

    void assemble(const Header *header,
                  const void *payload,
                  const size_t payload_len) override
    {
        origflexframegen_reset(fg_);
        origflexframegen_assemble(fg_,
                                  reinterpret_cast<unsigned char*>(const_cast<Header*>(header)),
                                  static_cast<unsigned char*>(const_cast<void*>(payload)),
                                  payload_len);
    }

    unsigned getOversampleRate(void) override
    {
        return 2;
    }

    // Number of samples generated by a call to origflexframegen_write_samples.
    static constexpr size_t NGEN = 2;

    size_t assembledSize(void) override
    {
        return NGEN*origflexframegen_getframelen(fg_);
    }

    size_t maxModulatedSamples(void) override
    {
        return NGEN;
    }

    bool modulateSamples(std::complex<float> *buf, size_t &nw) override
    {
        nw = NGEN;

        return origflexframegen_write_samples(fg_, buf);
    }

protected:
    /* @brief Flexframe generator object */
    origflexframegen fg_;

    void reconfigureHeader(void) override
    {
        origflexframegenprops_s props;

        mcs2genprops(header_mcs_, props);
        origflexframegen_set_header_props(fg_, &props);
        origflexframegen_set_header_len(fg_, sizeof(Header));
    }

    void reconfigurePayload(void) override
    {
        origflexframegenprops_s props;

        mcs2genprops(payload_mcs_, props);
        origflexframegen_setprops(fg_, &props);
    }
};

class FlexFrameDemodulator : virtual public Demodulator {
public:
    FlexFrameDemodulator(const MCS &header_mcs,
                         bool soft_header,
                         bool soft_payload)
      : Demodulator(header_mcs, soft_header, soft_payload)
    {
        std::lock_guard<std::mutex> liquid_lock(Liquid::mutex);
        std::lock_guard<std::mutex> fftw_lock(fftw::mutex);

        fs_ = origflexframesync_create(&Demodulator::liquid_callback,
                                       static_cast<Demodulator*>(this));

        reconfigureHeader();
        reconfigureSoftDecode();
    }

    virtual ~FlexFrameDemodulator()
    {
        if (fs_) {
            std::lock_guard<std::mutex> liquid_lock(Liquid::mutex);
            std::lock_guard<std::mutex> fftw_lock(fftw::mutex);

            origflexframesync_destroy(fs_);
        }
    }

    FlexFrameDemodulator() = delete;

    FlexFrameDemodulator(const FlexFrameDemodulator &) = delete;
    FlexFrameDemodulator(FlexFrameDemodulator &&) = delete;

    FlexFrameDemodulator &operator==(const FlexFrameDemodulator &) = delete;
    FlexFrameDemodulator &operator!=(const FlexFrameDemodulator &) = delete;

    unsigned getOversampleRate(void) override
    {
        return 2;
    }

    bool isFrameOpen(void) override
    {
        return origflexframesync_is_frame_open(fs_);
    }

    void print(void) override
    {
        origflexframesync_print(fs_);
    }

    void reset(void) override
    {
        origflexframesync_reset(fs_);
    }

    void demodulateSamples(const std::complex<float> *buf,
                           const size_t n) override
    {
        origflexframesync_execute(fs_, const_cast<std::complex<float>*>(buf), n);
    }

protected:
    /* @brief Flexframe synchronizer object */
    origflexframesync fs_;

    void reconfigureHeader(void) override
    {
        origflexframegenprops_s props;

        mcs2genprops(header_mcs_, props);
        origflexframesync_set_header_props(fs_, &props);
        origflexframesync_set_header_len(fs_, sizeof(Header));
    }

    void reconfigureSoftDecode(void) override
    {
        origflexframesync_decode_header_soft(fs_, soft_header_);
        origflexframesync_decode_payload_soft(fs_, soft_payload_);
    }
};

}

#endif /* LIQUID_FLEXFRAME_HH_ */
