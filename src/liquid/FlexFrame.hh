#ifndef LIQUID_FLEXFRAME_HH_
#define LIQUID_FLEXFRAME_HH_

#include <complex>
#include <functional>

#include <liquid/liquid.h>

#include "liquid/PHY.hh"

namespace Liquid {

class FlexFrameModulator : virtual public Modulator {
public:
    FlexFrameModulator()
    {
        std::lock_guard<std::mutex> lck(Liquid::mutex);

        origflexframegenprops_s props;

        mcs2flexframegenprops(payload_mcs_, props);
        fg_ = origflexframegen_create(&props);

        setHeaderMCS(header_mcs_);
    }

    virtual ~FlexFrameModulator()
    {
        if (fg_)
            origflexframegen_destroy(fg_);
    }

    FlexFrameModulator(const FlexFrameModulator &) = delete;
    FlexFrameModulator(FlexFrameModulator &&) = delete;

    FlexFrameModulator &operator=(const FlexFrameModulator &) = delete;
    FlexFrameModulator &operator=(FlexFrameModulator &&) = delete;

    void print(void) override
    {
        origflexframegen_print(fg_);
    }

    void assemble(const void *header,
                  const void *payload,
                  const size_t payload_len) override
    {
        origflexframegen_reset(fg_);
        origflexframegen_assemble(fg_,
                                  static_cast<unsigned char*>(const_cast<void*>(header)),
                                  static_cast<unsigned char*>(const_cast<void*>(payload)),
                                  payload_len);
    }

    virtual unsigned getOversampleRate(void)
    {
        return 2;
    }

    // Number of samples generated by a call to origflexframegen_write_samples.
    static constexpr size_t NGEN = 2;

    size_t assembledSize(void) override
    {
        return NGEN*origflexframegen_getframelen(fg_);
    }

    size_t maxModulatedSamples(void) override
    {
        return NGEN;
    }

    bool modulateSamples(std::complex<float> *buf, size_t &nw) override
    {
        nw = NGEN;

        return origflexframegen_write_samples(fg_, buf);
    }

protected:
    /* @brief Flexframe generator object */
    origflexframegen fg_;

    void reconfigureHeader(void) override
    {
#if LIQUID_VERSION_NUMBER >= 1003001
        origflexframegenprops_s props;

        mcs2flexframegenprops(header_mcs_, props);
        origflexframegen_set_header_props(fg_, &props);
        origflexframegen_set_header_len(fg_, sizeof(Header));
#endif /* LIQUID_VERSION_NUMBER >= 1003001 */
    }

    void reconfigurePayload(void) override
    {
        origflexframegenprops_s props;

        mcs2flexframegenprops(payload_mcs_, props);
        origflexframegen_setprops(fg_, &props);
    }
};

class FlexFrameDemodulator : virtual public Demodulator {
public:
    FlexFrameDemodulator(bool soft_header,
                         bool soft_payload)
      : Demodulator(soft_header, soft_payload)
    {
        std::lock_guard<std::mutex> lck(Liquid::mutex);

        fs_ = origflexframesync_create(&Demodulator::liquid_callback,
                                       static_cast<Demodulator*>(this));

        setHeaderMCS(header_mcs_);
    }

    virtual ~FlexFrameDemodulator()
    {
        if (fs_)
            origflexframesync_destroy(fs_);
    }

    FlexFrameDemodulator(const FlexFrameDemodulator &) = delete;
    FlexFrameDemodulator(FlexFrameDemodulator &&) = delete;

    FlexFrameDemodulator &operator==(const FlexFrameDemodulator &) = delete;
    FlexFrameDemodulator &operator!=(const FlexFrameDemodulator &) = delete;

    virtual unsigned getOversampleRate(void)
    {
        return 2;
    }

    void print(void) override
    {
        origflexframesync_print(fs_);
    }

    void reset(void) override
    {
        origflexframesync_reset(fs_);
    }

    void demodulateSamples(const std::complex<float> *buf,
                           const size_t n) override
    {
        origflexframesync_execute(fs_, const_cast<std::complex<float>*>(buf), n);
    }

protected:
    /* @brief Flexframe synchronizer object */
    origflexframesync fs_;

    void reconfigureHeader(void) override
    {
#if LIQUID_VERSION_NUMBER >= 1003001
        origflexframegenprops_s props;

        mcs2flexframegenprops(header_mcs_, props);
        origflexframesync_set_header_props(fs_, &props);
        origflexframesync_set_header_len(fs_, sizeof(Header));
#endif /* LIQUID_VERSION_NUMBER >= 1003001 */
    }

    void reconfigureSoftDecode(void) override
    {
#if LIQUID_VERSION_NUMBER >= 1003001
        origflexframesync_decode_header_soft(fs_, soft_header_);
        origflexframesync_decode_payload_soft(fs_, soft_payload_);
#endif /* LIQUID_VERSION_NUMBER >= 1003001 */
    }
};

}

#endif /* LIQUID_FLEXFRAME_HH_ */
