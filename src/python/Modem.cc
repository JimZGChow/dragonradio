// Copyright 2018-2020 Drexel University
// Author: Geoffrey Mainland <mainland@drexel.edu>

#include <pybind11/pybind11.h>
#include <pybind11/numpy.h>
#include <pybind11/stl.h>

#include "phy/Modem.hh"
#include "python/PyModules.hh"

// Initial modulation buffer size
const size_t kInitialModbufSize = 16384;

py::array_t<std::complex<float>> modulate(Modulator &mod,
                                          const Header &hdr,
                                          py::buffer payload)
{
    auto buf = payload.request();

    // Release the GIL while we assemble a packet
    {
        py::gil_scoped_release gil;

        mod.assemble(&hdr, buf.ptr, buf.size*buf.itemsize);
    }

    // Allocate numpy array for modulated data
    py::array_t<std::complex<float>> iqarr(kInitialModbufSize);
    auto                             iqbuf = iqarr.request();
    size_t                           nsamples = 0;

    // Relase the GIL and modulate samples
    {
        // Max number of samples generated by modulateSamples
        const size_t kMaxModSamples = mod.maxModulatedSamples();
        // Number of samples written
        size_t nw;
        // Flag indicating when we've reached the last symbol
        bool last_symbol = false;

        while (!last_symbol) {
            last_symbol = mod.modulateSamples(&static_cast<std::complex<float>*>(iqbuf.ptr)[nsamples], nw);
            nsamples += nw;

            // If we can't add another nw samples to the current IQ buffer, resize it.
            if (nsamples + kMaxModSamples > (size_t) iqbuf.size) {
                // We need to re-acquire the GIL here to resize the numpy array
                py::gil_scoped_acquire gil;

                iqarr.resize({2*iqarr.size()});
                iqbuf = iqarr.request();
            }
        }
    }

    // Resize the final buffer to the number of samples generated.
    iqarr.resize({nsamples});

    return iqarr;
}


using Demod = std::pair<std::optional<Header>,
                        std::optional<py::bytes>>;

std::vector<Demod> demodulate(Demodulator &demod,
                              py::array_t<std::complex<float>, py::array::c_style | py::array::forcecast> sig)
{
    // We use std::string to store payloads and batch convert once demodulation
    // is done
    using LocalDemod = std::pair<std::optional<Header>,
                                 std::optional<std::string>>;

    std::vector<LocalDemod> local_pkts;

    // Get the signal to demodulate
    auto buf = sig.request();

    // Release the GIL and demodulate
    {
        py::gil_scoped_release gil;

        Demodulator::callback_t cb = [&](bool header_test,
                                         bool header_valid,
                                         bool payload_valid,
                                         const Header* header,
                                         void *payload,
                                         size_t payload_len,
                                         void *stats_)
        {
            std::optional<Header>    h;
            std::optional<py::bytes> p;

            if (header_test)
                return 1;

            if (header_valid)
                h = *((Header *) header);

            if (payload_valid)
                p = std::string(reinterpret_cast<char*>(payload), payload_len);

            local_pkts.emplace_back(std::make_pair(h, p));

            return 0;
        };

        demod.demodulate(static_cast<std::complex<float>*>(buf.ptr), buf.size, cb);
    }

    // Now we have the GIL, so we can convert payloads to Python bytes objects
    {
        std::vector<Demod> pkts;

        for (auto [h, p] : local_pkts)
            pkts.emplace_back(std::make_pair(std::move(h), p ? std::make_optional(py::bytes(*p)) : std::nullopt));

        return pkts;
    }
}

void exportModem(py::module &m)
{
    // Export class MCS to Python
    py::class_<MCS, std::shared_ptr<MCS>>(m, "MCS")
        .def_property_readonly("rate",
            &MCS::getRate,
            "Approximate rate (bps)")
        .def("__str__", [](const MCS &self) {
            return self.description();
         })
    ;

    // Export class Modulator to Python
    py::class_<Modulator, std::shared_ptr<Modulator>>(m, "Modulator")
        .def("modulate",
            modulate,
            "Modulate a packet")
        ;

    // Export class Demodulator to Python
    py::class_<Demodulator, std::shared_ptr<Demodulator>>(m, "Demodulator")
        .def_property_readonly("is_frame_open",
            &Demodulator::isFrameOpen)
        .def("reset",
            &Demodulator::reset,
            "Reset demodulator state")
        .def("demodulate",
            demodulate,
            "Demodulate a signal")
        ;
}
