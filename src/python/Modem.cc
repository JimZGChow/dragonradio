#include <pybind11/pybind11.h>
#include <pybind11/numpy.h>
#include <pybind11/stl.h>

#include "phy/Modem.hh"
#include "python/PyModules.hh"

// Initial modulation buffer size
const size_t kInitialModbufSize = 16384;

py::array_t<std::complex<float>> modulate(Modulator &mod,
                                          const Header &hdr,
                                          py::buffer payload)
{
    auto buf = payload.request();

    mod.assemble(&hdr, buf.ptr, buf.size);

    py::array_t<std::complex<float>> iqarr(kInitialModbufSize);
    auto                             iqbuf = iqarr.request();

    // Number of generated samples in the buffer
    size_t nsamples = 0;
    // Max number of samples generated by modulateSamples
    const size_t kMaxModSamples = mod.maxModulatedSamples();
    // Number of samples written
    size_t nw;
    // Flag indicating when we've reached the last symbol
    bool last_symbol = false;

    while (!last_symbol) {
        last_symbol = mod.modulateSamples(&static_cast<std::complex<float>*>(iqbuf.ptr)[nsamples], nw);
        nsamples += nw;

        // If we can't add another nw samples to the current IQ buffer, resize it.
        if (nsamples + kMaxModSamples > (size_t) iqbuf.size) {
            iqarr.resize({2*iqarr.size()});
            iqbuf = iqarr.request();
        }
    }

    // Resize the final buffer to the number of samples generated.
    iqarr.resize({nsamples});

    return iqarr;
}

using demod_vec = std::vector<std::pair<std::optional<Header>,
                                        std::optional<py::bytes>>>;

demod_vec demodulate(Demodulator &demod,
                     py::array_t<std::complex<float>, py::array::c_style | py::array::forcecast> sig)
{
    demod_vec packets;

    auto buf = sig.request();

    Demodulator::callback_t cb = [&](bool header_test,
                                     bool header_valid,
                                     bool payload_valid,
                                     const Header* header,
                                     void *payload,
                                     size_t payload_len,
                                     void *stats_)
    {
        std::optional<Header>    h;
        std::optional<py::bytes> p;

        if (header_test)
            return 1;

        if (header_valid)
            h = *((Header *) header);

        if (payload_valid)
            p = py::bytes(reinterpret_cast<char*>(payload), payload_len);

        packets.push_back(std::make_pair(h, p));

        return 0;
    };

    demod.demodulate(static_cast<std::complex<float>*>(buf.ptr), buf.size, cb);

    return packets;
}

void exportModem(py::module &m)
{
    // Export class MCS to Python
    py::class_<MCS, std::shared_ptr<MCS>>(m, "MCS")
        .def(py::init<>())
        .def(py::init<crc_scheme,
                      fec_scheme,
                      fec_scheme,
                      modulation_scheme>())
        .def_readwrite("check", &MCS::check, "Data validity check")
        .def_readwrite("fec0", &MCS::fec0, "Inner FEC")
        .def_readwrite("fec1", &MCS::fec1, "Outer FEC")
        .def_readwrite("ms", &MCS::ms, "Modulation scheme")
        .def_property_readonly("rate", &MCS::getRate, "Approximate rate (bps)")
        .def("__repr__", [](const MCS& self) {
            return py::str("MCS(check={}, fec0={}, fec1={}, ms={})").format(self.check, self.fec0, self.fec1, self.ms);
         })
    ;

    // Export class Header to Python
    py::class_<Header, std::shared_ptr<Header>>(m, "Header")
        .def(py::init<>())
        .def(py::init<uint8_t,
                      uint8_t,
                      uint16_t>())
        .def_readwrite("curhop", &Header::curhop, "Current hop")
        .def_readwrite("nexthop", &Header::nexthop, "Next hop")
        .def_readwrite("seq", &Header::seq, "Packet sequence number")
        .def("__repr__", [](const Header& self) {
            return py::str("Header(curhop={}, nexthop={}, seq={})").\
            format(self.curhop, self.nexthop, (unsigned) self.seq);
         })
        ;

    // Export class Modulator to Python
    py::class_<Modulator, std::shared_ptr<Modulator>>(m, "Modulator")
        .def("modulate",
            modulate,
            "Modulate a packet")
        ;

    // Export class Demodulator to Python
    py::class_<Demodulator, std::shared_ptr<Demodulator>>(m, "Demodulator")
        .def_property_readonly("is_frame_open",
            &Demodulator::isFrameOpen)
        .def("reset",
            &Demodulator::reset,
            "Reset demodulator state")
        .def("demodulate",
            demodulate,
            "Demodulate a signal")
        ;
}
